<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>화살표 리듬 게임</title>
<style>
body {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    background-color: #1a1a1a;
    color: #fff;
    font-family: 'Arial', sans-serif;
    margin: 0;
    height: 100vh;
}
#gameContainer {
    position: relative;
    width: 300px;
    height: 500px;
    border: 5px solid #00f;
    background-color: #333;
    overflow: hidden;
}
/* 판정선 스타일 */
#judgeLine {
    position: absolute;
    bottom: 50px; /* 화면 하단에서 50px 위 */
    left: 0;
    width: 100%;
    height: 5px;
    background-color: #ff0;
    box-shadow: 0 0 10px #ff0;
    z-index: 10;
}
/* 화살표 노트 스타일 */
.note {
    position: absolute;
    width: 60px;
    height: 30px;
    background-color: rgba(255, 255, 255, 0.8);
    text-align: center;
    line-height: 30px;
    font-size: 20px;
    font-weight: bold;
    color: #000;
    border-radius: 5px;
}
/* 점수 표시 */
#scoreDisplay {
    margin-bottom: 10px;
    font-size: 24px;
}
/* 판정 결과 텍스트 */
#judgmentText {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 40px;
    font-weight: bold;
    color: #f00;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 20;
}
/* 게임 오버 */
#gameOver {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 30;
}
#gameOver button {
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
    margin-top: 15px;
}
</style>
</head>
<body>
<div id="scoreDisplay">점수: <span id="score">0</span></div>
<div id="gameContainer">
    <div id="judgeLine"></div>
    <div id="judgmentText"></div>
    <div id="gameOver">
        GAME OVER!
        <div id="finalScore"></div>
        <button onclick="startGame()">다시 시작</button>
    </div>
</div>
<div class="controls">
    <p>A, S, K, L 키를 눌러 노트를 맞추세요!</p>
</div>
<script>
// 1. 요소 가져오기
const container = document.getElementById('gameContainer');
const scoreDisplay = document.getElementById('score');
const judgmentText = document.getElementById('judgmentText');
const gameOverScreen = document.getElementById('gameOver');
const finalScoreDisplay = document.getElementById('finalScore');

// 2. 게임 설정 변수
const NOTE_SPEED = 5; // 노트 낙하 속도 (픽셀/프레임)
const JUDGE_Y = container.offsetHeight - 50; // 판정선 Y 좌표 (CSS bottom: 50px와 일치)
const PERFECT_RANGE = 20; // 픽셀 단위
const GOOD_RANGE = 60; // 픽셀 단위
const NOTE_HEIGHT = 30; // 노트 높이 (CSS와 일치)
let score = 0;
let notes = [];
let frames = 0;
let gameActive = false;
let gameLoopId;

// ✨ 새로운 키 매핑 정의 (방향키 대신)
const KEY_MAP = {
    'A': 'ArrowLeft',   // A 키 -> 왼쪽 레인
    'S': 'ArrowDown',   // S 키 -> 아래쪽 레인
    'K': 'ArrowUp',     // K 키 -> 위쪽 레인
    'L': 'ArrowRight'   // L 키 -> 오른쪽 레인
};
const REVERSE_KEY_MAP = {
    'ArrowLeft': 'A',
    'ArrowDown': 'S',
    'ArrowUp': 'K',
    'ArrowRight': 'L'
};

// 3. 노트 클래스 정의
class Note {
    // direction은 내부적으로 'ArrowLeft', 'ArrowDown', 'ArrowUp', 'ArrowRight'를 계속 사용합니다.
    constructor(direction) {
        this.direction = direction; 
        this.x = this.getLaneX(direction);
        this.y = 0; // 화면 맨 위에서 시작
        this.element = document.createElement('div');
        this.element.className = 'note';
        // 텍스트를 해당하는 키로 변경
        this.element.textContent = REVERSE_KEY_MAP[direction]; 
        this.element.style.left = `${this.x}px`;
        this.element.style.background = this.getArrowColor(direction);
        container.appendChild(this.element);
    }
    
    getLaneX(direction) {
        // 4개 레인 위치 (container 너비 300px, 노트 너비 60px 가정)
        const laneWidth = 75;
        switch (direction) {
            case 'ArrowLeft': return 0 + (laneWidth - 60) / 2;
            case 'ArrowDown': return laneWidth * 1 + (laneWidth - 60) / 2;
            case 'ArrowUp': return laneWidth * 2 + (laneWidth - 60) / 2;
            case 'ArrowRight':return laneWidth * 3 + (laneWidth - 60) / 2;
        }
    }

    // 노트에 표시되는 텍스트를 키 문자로 변경했으므로 이 함수는 사용하지 않지만, 노트 색상은 유지합니다.
    getArrowColor(direction) {
        switch (direction) {
            case 'ArrowLeft': return '#FFFFFF';
            case 'ArrowDown': return '#FF0000';
            case 'ArrowUp': return '#00FF00';
            case 'ArrowRight': return '#0000FF';
        }
    }
    
    update() {
        this.y += NOTE_SPEED;
        this.element.style.top = `${this.y}px`;
    }
    
    remove() {
        container.removeChild(this.element);
    }
}

// 4. 게임 시작 함수
function startGame() {
    // 초기화
    score = 0;
    scoreDisplay.textContent = score;
    notes.forEach(note => note.remove());
    notes = [];
    frames = 0;
    gameOverScreen.style.display = 'none';
    gameActive = true;
    NOTE_SPAWN_INTERVAL = 60;

    // 게임 루프 시작
    if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
    }
    gameLoop();
}

// 5. 판정 표시 함수
function showJudgment(text, color) {
    judgmentText.textContent = text;
    judgmentText.style.color = color;
    judgmentText.style.opacity = 1;
    setTimeout(() => {
        judgmentText.style.opacity = 0;
    }, 500);
}

// 6. 노트 판정 및 점수 계산
// keyPressed는 눌린 키의 'Code'가 아닌 'Key' 값 (예: 'a', 's', 'k', 'l') 입니다.
function judgeNote(keyPressed) {
    if (!gameActive) return;

    // 눌린 키를 내부적으로 사용하는 direction 값으로 변환
    const mappedDirection = KEY_MAP[keyPressed.toUpperCase()];
    if (!mappedDirection) return; // 매핑되지 않은 키는 무시

    // 판정선 근처의 노트를 찾음
    let closestNoteIndex = -1;
    let minDistance = Infinity;

    for (let i = 0; i < notes.length; i++) {
        if (notes[i].direction === mappedDirection) { // 매핑된 방향과 일치하는 노트만 확인
            // 노트의 중심과 판정선의 중심 간의 거리
            const noteCenterY = notes[i].y + NOTE_HEIGHT / 2;
            const judgeCenterY = JUDGE_Y + 5 / 2;
            const distance = Math.abs(noteCenterY - judgeCenterY);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestNoteIndex = i;
            }
        }
    }

    if (closestNoteIndex !== -1) {
        const noteToJudge = notes[closestNoteIndex];
        let judgment = '';
        let points = 0;
        let color = '';

        // 판정
        if (minDistance <= PERFECT_RANGE) {
            judgment = 'PERFECT!';
            points = 100;
            color = '#0f0';
        } else if (minDistance <= GOOD_RANGE) {
            judgment = 'GOOD';
            points = 50;
            color = '#0ff';
        } else {
            // 미스 범위보다 멀리 떨어진 경우 (오차 범위 밖)
            return;
        }

        // 점수 업데이트 및 노트 제거
        score += points;
        scoreDisplay.textContent = score;
        showJudgment(judgment, color);
        noteToJudge.remove();
        notes.splice(closestNoteIndex, 1);
    }
}

// 7. 입력 이벤트 리스너
document.addEventListener('keydown', (e) => {
    // 눌린 키의 대문자 버전을 확인
    const keyPressed = e.key.toUpperCase();
    
    // KEY_MAP에 정의된 키인지 확인
    if (KEY_MAP.hasOwnProperty(keyPressed)) {
        // A, S, K, L 키 입력을 막기 위해 preventDefault
        e.preventDefault(); 
        judgeNote(keyPressed);
    }
});

// 8. 메인 게임 루프
function gameLoop() {
    if (!gameActive) return;

    frames++
    if(Math.floor(Math.random() * 40) === 0){
        // 랜덤 생성 확률
        const directions = ['ArrowLeft', 'ArrowDown', 'ArrowUp', 'ArrowRight'];
        const randomDirection = directions[Math.floor(Math.random() * directions.length)];
        notes.push(new Note(randomDirection));
    }

    // 노트 업데이트 및 미스 판정
    for (let i = notes.length - 1; i >= 0; i--) {
        const note = notes[i];
        note.update();

        // 노트가 판정선을 지나 화면 밖으로 나간 경우 (미스)
        // 판정선 Y 좌표 + 노트 높이 + 판정 범위(GOOD_RANGE)를 벗어났는지 확인
        if (note.y > JUDGE_Y + NOTE_HEIGHT + GOOD_RANGE) {
            showJudgment('MISS', '#f00');
            note.remove();
            notes.splice(i, 1);
            
            // 미스 시 게임 오버
            gameOver();
        }
    }

    gameLoopId = requestAnimationFrame(gameLoop);
}

// 9. 게임 오버 함수
function gameOver() {
    gameActive = false;
    cancelAnimationFrame(gameLoopId);
    finalScoreDisplay.textContent = `최종 점수: ${score}`;
    gameOverScreen.style.display = 'flex';
}

// 초기 시작
startGame();
</script>
</body>
</html>